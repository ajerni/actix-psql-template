use actix_web::{web, App, HttpServer, Responder, Result};
use sqlx::{PgPool, Row};

async fn index() -> impl Responder {
    "Hello from Actix Web!"
}

async fn health() -> impl Responder {
    "OK"
}

async fn name(path: web::Path<String>) -> impl Responder {
    format!("Hello, {}!", path.into_inner())
}

async fn db_check(pool: web::Data<PgPool>) -> Result<impl Responder> {
    let result = sqlx::query("SELECT NOW() as current_time, version() as pg_version")
        .fetch_one(pool.get_ref())
        .await;

    match result {
        Ok(row) => {
            let current_time: chrono::DateTime<chrono::Utc> = row.get("current_time");
            let pg_version: String = row.get("pg_version");
            Ok(format!(
                "Database connected!\nPostgreSQL version: {}\nCurrent time: {}",
                pg_version, current_time
            ))
        }
        Err(e) => Ok(format!("Database error: {}", e)),
    }
}

// Generated by setup-db.sh - DO NOT EDIT MANUALLY
// Table: actfinal_table

#[derive(Debug, serde::Serialize, serde::Deserialize, sqlx::FromRow)]
pub struct ActfinalRecord {
    pub id: i32,
    pub created_on: chrono::DateTime<chrono::Utc>,
    pub changed_on: chrono::DateTime<chrono::Utc>,
    pub name: String,
    pub age: i32,
    pub aktiv: bool,
}

#[derive(serde::Deserialize)]
pub struct CreateActfinalRecordRequest {
    pub name: String,
    pub age: i32,
    pub aktiv: bool,
}

// CRUD operations
async fn create_actfinal(
    pool: web::Data<PgPool>,
    record: web::Json<CreateActfinalRecordRequest>,
) -> Result<impl Responder> {
    let fields: Vec<&str> = vec![
        "name",
        "age",
        "aktiv",
    ];
    let fields_str = fields.join(", ");
    let placeholders: Vec<String> = (1..=fields.len()).map(|i| format!("${}", i)).collect();
    let values_str = placeholders.join(", ");
    let query = format!("INSERT INTO actfinal_table ({}) VALUES ({}) RETURNING *", fields_str, values_str);

    let result = sqlx::query_as::<_, ActfinalRecord>(&query)
        .bind(&record.name)
        .bind(&record.age)
        .bind(&record.aktiv)
        .fetch_one(pool.get_ref())
        .await;

    match result {
        Ok(record) => Ok(web::Json(record)),
        Err(e) => {
            eprintln!("Database error: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to create record"))
        }
    }
}

async fn get_actfinal(
    pool: web::Data<PgPool>,
    id: web::Path<i32>,
) -> Result<impl Responder> {
    let result = sqlx::query_as::<_, ActfinalRecord>(
        "SELECT * FROM actfinal_table WHERE id = $1"
    )
    .bind(id.into_inner())
    .fetch_optional(pool.get_ref())
    .await;

    match result {
        Ok(Some(record)) => Ok(web::Json(record)),
        Ok(None) => Err(actix_web::error::ErrorNotFound("Record not found")),
        Err(e) => {
            eprintln!("Database error: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to get record"))
        }
    }
}

async fn list_actfinal(
    pool: web::Data<PgPool>,
) -> Result<impl Responder> {
    let result = sqlx::query_as::<_, ActfinalRecord>(
        "SELECT * FROM actfinal_table ORDER BY id"
    )
    .fetch_all(pool.get_ref())
    .await;

    match result {
        Ok(records) => Ok(web::Json(records)),
        Err(e) => {
            eprintln!("Database error: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to list records"))
        }
    }
}

async fn update_actfinal(
    pool: web::Data<PgPool>,
    id: web::Path<i32>,
    record: web::Json<CreateActfinalRecordRequest>,
) -> Result<impl Responder> {
    let field_names: Vec<&str> = vec![
        "name",
        "age",
        "aktiv",
    ];
    let set_clauses: Vec<String> = field_names.iter().enumerate().map(|(i, name)| format!("{} = ${}", name, i + 2)).collect();
    let set_clause = set_clauses.join(", ");
    let query = format!("UPDATE actfinal_table SET {} WHERE id = $1 RETURNING *", set_clause);

    let result = sqlx::query_as::<_, ActfinalRecord>(&query)
        .bind(id.into_inner())
        .bind(&record.name)
        .bind(&record.age)
        .bind(&record.aktiv)
        .fetch_optional(pool.get_ref())
        .await;

    match result {
        Ok(Some(record)) => Ok(web::Json(record)),
        Ok(None) => Err(actix_web::error::ErrorNotFound("Record not found")),
        Err(e) => {
            eprintln!("Database error: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to update record"))
        }
    }
}

async fn delete_actfinal(
    pool: web::Data<PgPool>,
    id: web::Path<i32>,
) -> Result<impl Responder> {
    let result = sqlx::query("DELETE FROM actfinal_table WHERE id = $1")
        .bind(id.into_inner())
        .execute(pool.get_ref())
        .await;

    match result {
        Ok(rows) => {
            if rows.rows_affected() > 0 {
                Ok(web::Json(serde_json::json!({"message": "Record deleted"})))
            } else {
                Err(actix_web::error::ErrorNotFound("Record not found"))
            }
        }
        Err(e) => {
            eprintln!("Database error: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to delete record"))
        }
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Database connection string
    // From within Docker network, use service name: actfinal-postgres
    // From host machine, use: localhost:5433
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://actfinal_user:qwert@actfinal-postgres:5432/actfinal_db".to_string());

    // Create database connection pool
    let pool = PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to database");

    // Test the connection
    sqlx::query("SELECT 1")
        .execute(&pool)
        .await
        .expect("Failed to execute test query");

    println!("âœ“ Database connection established");

    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(pool.clone()))
            .service(web::scope("/api")
                .route("/name/{name}", web::get().to(name))
                .route("/db", web::get().to(db_check))
                .route("/actfinal", web::post().to(create_actfinal))
                .route("/actfinal", web::get().to(list_actfinal))
                .route("/actfinal/{id}", web::get().to(get_actfinal))
                .route("/actfinal/{id}", web::put().to(update_actfinal))
                .route("/actfinal/{id}", web::delete().to(delete_actfinal))
            )
            .route("/health", web::get().to(health))
            .route("/", web::get().to(index))
    })
    .bind("0.0.0.0:8080")?
    .run()
    .await
}
