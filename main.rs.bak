use actix_web::{web, App, HttpServer, Responder, Result, Error, HttpResponse};
use actix_web::dev::{ServiceRequest, ServiceResponse, Service, Transform};
use actix_cors::Cors;
use sqlx::{PgPool, Row};
use std::future::{ready, Ready};
use futures_util::future::LocalBoxFuture;

async fn index() -> impl Responder {
    "Hello from Actix Web!"
}

async fn health() -> impl Responder {
    "OK"
}

async fn name(path: web::Path<String>) -> impl Responder {
    format!("Hello, {}!", path.into_inner())
}

async fn db_check(pool: web::Data<PgPool>) -> Result<impl Responder> {
    let result = sqlx::query("SELECT NOW() as current_time, version() as pg_version")
        .fetch_one(pool.get_ref())
        .await;

    match result {
        Ok(row) => {
            let current_time: chrono::DateTime<chrono::Utc> = row.get("current_time");
            let pg_version: String = row.get("pg_version");
            Ok(format!(
                "Database connected!\nPostgreSQL version: {}\nCurrent time: {}",
                pg_version, current_time
            ))
        }
        Err(e) => Ok(format!("Database error: {}", e)),
    }
}

// Authorization Middleware
pub struct AuthMiddleware {
    expected_api_key: String,
}

impl AuthMiddleware {
    pub fn new(expected_api_key: String) -> Self {
        AuthMiddleware { expected_api_key }
    }
}

impl<S, B> Transform<S, ServiceRequest> for AuthMiddleware
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
    S::Future: 'static,
    B: 'static,
{
    type Response = ServiceResponse<B>;
    type Error = Error;
    type InitError = ();
    type Transform = AuthMiddlewareService<S>;
    type Future = Ready<Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ready(Ok(AuthMiddlewareService {
            service,
            expected_api_key: self.expected_api_key.clone(),
        }))
    }
}

pub struct AuthMiddlewareService<S> {
    service: S,
    expected_api_key: String,
}

impl<S, B> Service<ServiceRequest> for AuthMiddlewareService<S>
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
    S::Future: 'static,
    B: 'static,
{
    type Response = ServiceResponse<B>;
    type Error = Error;
    type Future = LocalBoxFuture<'static, Result<Self::Response, Self::Error>>;

    actix_web::dev::forward_ready!(service);

    fn call(&self, req: ServiceRequest) -> Self::Future {
        let expected_key = self.expected_api_key.clone();
        
        // Check for x-api-key header
        let auth_header = req.headers().get("x-api-key");
        
        match auth_header {
            Some(header_value) if header_value.to_str().unwrap_or("") == expected_key => {
                // Valid API key, proceed
                let fut = self.service.call(req);
                Box::pin(async move {
                    let res = fut.await?;
                    Ok(res)
                })
            }
            _ => {
                // Invalid or missing API key
                Box::pin(async move {
                    Err(actix_web::error::ErrorUnauthorized("Invalid or missing x-api-key header"))
                })
            }
        }
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Database connection string
    // From within Docker network, use service name: aaabbb-postgres
    // From host machine, use: localhost:5433
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://aaabbb_user:qwert@aaabbb-postgres:5432/aaabbb_db".to_string());

    // Create database connection pool
    let pool = PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to database");

    // Test the connection
    sqlx::query("SELECT 1")
        .execute(&pool)
        .await
        .expect("Failed to execute test query");

    println!("✓ Database connection established");

    // API key for authorization
    let api_key = "aaabbb-apisecret".to_string();
    println!("✓ API Key: {}", api_key);

    HttpServer::new(move || {
        // Configure CORS - Allow all origins with credentials
        let cors = Cors::default()
            .allow_any_origin()
            .allowed_methods(vec!["GET", "POST", "PUT", "DELETE", "OPTIONS"])
            .allowed_headers(vec![
                actix_web::http::header::CONTENT_TYPE,
                actix_web::http::header::HeaderName::from_static("x-api-key"),
            ])
            .supports_credentials()
            .max_age(3600);

        App::new()
            .wrap(cors)  // CORS middleware (applied first, outermost)
            .app_data(web::Data::new(pool.clone()))
            .service(
                web::scope("/api")
                    .wrap(AuthMiddleware::new(api_key.clone()))  // Auth middleware (applied after CORS)
                    .route("/name/{name}", web::get().to(name))
                    .route("/db", web::get().to(db_check))
            )
            .route("/health", web::get().to(health))
            .route("/", web::get().to(index))
    })
    .bind("0.0.0.0:8080")?
    .run()
    .await
}
