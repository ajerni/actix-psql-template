use actix_web::{web, App, HttpServer, Responder, Result};
use sqlx::{PgPool, Row};

async fn index() -> impl Responder {
    "Hello from Actix Web!"
}

async fn health() -> impl Responder {
    "OK"
}

async fn name(path: web::Path<String>) -> impl Responder {
    format!("Hello, {}!", path.into_inner())
}

async fn db_check(pool: web::Data<PgPool>) -> Result<impl Responder> {
    let result = sqlx::query("SELECT NOW() as current_time, version() as pg_version")
        .fetch_one(pool.get_ref())
        .await;

    match result {
        Ok(row) => {
            let current_time: chrono::DateTime<chrono::Utc> = row.get("current_time");
            let pg_version: String = row.get("pg_version");
            Ok(format!(
                "Database connected!\nPostgreSQL version: {}\nCurrent time: {}",
                pg_version, current_time
            ))
        }
        Err(e) => Ok(format!("Database error: {}", e)),
    }
}

// Generated by setup-db.sh - DO NOT EDIT MANUALLY
// Table: atestb_table

#[derive(Debug, serde::Serialize, serde::Deserialize, sqlx::FromRow)]
pub struct AtestbRecord {
    pub id: i32,
    pub created_on: chrono::DateTime<chrono::Utc>,
    pub changed_on: chrono::DateTime<chrono::Utc>,
    pub name: String,
    pub age: i32,
    pub aktiv: bool,
}

#[derive(serde::Deserialize)]
pub struct CreateAtestbRecordRequest {
    pub name: String,
    pub age: i32,
    pub aktiv: bool,
}

// CRUD operations
async fn create_atestb(
    pool: web::Data<PgPool>,
    record: web::Json<CreateAtestbRecordRequest>,
) -> Result<impl Responder> {
    let fields: Vec<&str> = vec![
        "name",
        "age",
        "aktiv",
    ];
    let fields_str = fields.join(", ");

    match result {
        Ok(record) => Ok(web::Json(record)),
        Err(e) => {
            eprintln!("Database error: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to create record"))
        }
    }
}

async fn get_atestb(
    pool: web::Data<PgPool>,
    id: web::Path<i32>,
) -> Result<impl Responder> {
    let result = sqlx::query_as::<_, AtestbRecord>(
        "SELECT * FROM atestb_table WHERE id = $1"
    )
    .bind(id.into_inner())
    .fetch_optional(pool.get_ref())
    .await;

    match result {
        Ok(Some(record)) => Ok(web::Json(record)),
        Ok(None) => Err(actix_web::error::ErrorNotFound("Record not found")),
        Err(e) => {
            eprintln!("Database error: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to get record"))
        }
    }
}

async fn list_atestb(
    pool: web::Data<PgPool>,
) -> Result<impl Responder> {
    let result = sqlx::query_as::<_, AtestbRecord>(
        "SELECT * FROM atestb_table ORDER BY id"
    )
    .fetch_all(pool.get_ref())
    .await;

    match result {
        Ok(records) => Ok(web::Json(records)),
        Err(e) => {
            eprintln!("Database error: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to list records"))
        }
    }
}

async fn update_atestb(
    pool: web::Data<PgPool>,
    id: web::Path<i32>,
    record: web::Json<CreateAtestbRecordRequest>,
) -> Result<impl Responder> {
    let field_names: Vec<&str> = vec![
        "name",
        "age",
        "aktiv",
    ];

    match result {
        Ok(Some(record)) => Ok(web::Json(record)),
        Ok(None) => Err(actix_web::error::ErrorNotFound("Record not found")),
        Err(e) => {
            eprintln!("Database error: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to update record"))
        }
    }
}

async fn delete_atestb(
    pool: web::Data<PgPool>,
    id: web::Path<i32>,
) -> Result<impl Responder> {
    let result = sqlx::query("DELETE FROM atestb_table WHERE id = $1")
        .bind(id.into_inner())
        .execute(pool.get_ref())
        .await;

    match result {
        Ok(rows) => {
            if rows.rows_affected() > 0 {
                Ok(web::Json(serde_json::json!({"message": "Record deleted"})))
            } else {
                Err(actix_web::error::ErrorNotFound("Record not found"))
            }
        }
        Err(e) => {
            eprintln!("Database error: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to delete record"))
        }
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Database connection string
    // From within Docker network, use service name: atestb-postgres
    // From host machine, use: localhost:5433
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://atestb_user:qwert@atestb-postgres:5432/atestb_db".to_string());

    // Create database connection pool
    let pool = PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to database");

    // Test the connection
    sqlx::query("SELECT 1")
        .execute(&pool)
        .await
        .expect("Failed to execute test query");

    println!("âœ“ Database connection established");

    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(pool.clone()))
            .service(web::scope("/api")
                .route("/name/{name}", web::get().to(name))
                .route("/db", web::get().to(db_check))
                .route("/atestb", web::post().to(create_atestb))
                .route("/atestb", web::get().to(list_atestb))
                .route("/atestb/{id}", web::get().to(get_atestb))
                .route("/atestb/{id}", web::put().to(update_atestb))
                .route("/atestb/{id}", web::delete().to(delete_atestb))
            )
            .route("/health", web::get().to(health))
            .route("/", web::get().to(index))
    })
    .bind("0.0.0.0:8080")?
    .run()
    .await
}
